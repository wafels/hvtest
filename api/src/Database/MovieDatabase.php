<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
/**
 * Database_MovieDatabase Class definition
 *
 * PHP version 5
 *
 * @category Database
 * @package  Helioviewer
 * @author   Keith Hughitt <keith.hughitt@nasa.gov>
 * @license  http://www.mozilla.org/MPL/MPL-1.1.html Mozilla Public License 1.1
 * @link     http://launchpad.net/helioviewer.org
 */
/**
 * Provides methods for querying and storing movies generated by Helioviewer.org
 * 
 * @category Database
 * @package  Helioviewer
 * @author   Keith Hughitt <keith.hughitt@nasa.gov>
 * @license  http://www.mozilla.org/MPL/MPL-1.1.html Mozilla Public License 1.1
 * @link     http://launchpad.net/helioviewer.org
 */
class Database_MovieDatabase
{
    private $_dbConnection;

    /**
     * Creates an Database_MovieDatabase instance
     *
     * @return void
     */
    public function __construct()
    {
        $this->_dbConnection = false;
    }
    
    private function _dbConnect() {
        if ( $this->_dbConnection === false ) {
            include_once 'DbConnection.php';
            $this->_dbConnection = new Database_DbConnection();
        }
    }
    
    /**
     * Inserts a new movie entry into the database and returns it's id
     */
    public function insertMovie($startTime, $endTime, $imageScale, $roi, 
        $maxFrames, $watermark, $layerString, $layerBitMask, $eventString, 
        $eventsLabels, $scale, $scaleType, $scaleX, $scaleY, $numLayers, 
        $queueNum, $frameRate, $movieLength) {
        
        $sql = "INSERT INTO movies VALUES(NULL, NULL, ?, ?, ?, " 
             . "PolygonFromText(?), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, "
             . "?, NULL, NULL, NULL, NULL, NULL, NULL, NULL);";
               
        $startTime = isoDateToMySQL($startTime);
        $endTime   = isoDateToMySQL($endTime);
                 
        $this->_dbConnect();
        
        $stmt = $this->_dbConnection->link->prepare($sql);
        $stmt->bind_param('ssdsiisssiisddiiss', $startTime, $endTime, $imageScale, 
            $roi, $maxFrames, $watermark, $layerString, $layerBitMask, 
            $eventString, $eventsLabels, $scale, $scaleType, $scaleX, $scaleY, 
            $numLayers, $queueNum, $frameRate, $movieLength);

        $result = $stmt->execute();
        $id = $stmt->insert_id;
        $stmt->close();
        
        return $id;
    }
    
    /**
     * Creates a video entry in the movieFormats table
     */
    public function insertMovieFormat($id, $format)
    {         
        $this->_dbConnect();
        
        $sql = "INSERT INTO movieFormats VALUES(NULL, ?, ?, 0, NULL);";

        $stmt = $this->_dbConnection->link->prepare($sql);
        $stmt->bind_param('is', $id, $format);

        $result = $stmt->execute();
        $id = $stmt->insert_id;
        $stmt->close();
        
        return $id;
    }

    /**
     * Creates a new entry in the youtube table to track a movie uploaded to
     * YouTube.
     * 
     * @return void
     */
    public function insertYouTubeMovie($movieId, $title, $desc, $keywords, $share)
    {
        $this->_dbConnect();
    
        // Create the prepared statement
        $sql = "INSERT INTO youtube values (NULL, ?, NULL, NULL, ?, ?, ?, ?)";
        if ($stmt = $this->_dbConnection->link->prepare($sql)) {
            $stmt->bind_param('isssi', $movieId, $title, $desc, $keywords, $share);

            $result = $stmt->execute();
            $stmt->close();
            
            return $result;    
        }
        else {
            printf("Prepared Statement Error: %s\n", $this->_dbConnection->link->error);
        }
    }
    
    /**
     * Updates youtube entry to add youtube id if upload successfully completed
     */
    public function updateYouTubeMovie($movieId, $youtubeId)
    {
        $this->_dbConnect();
        
        $sql = "UPDATE youtube SET youtubeId='$youtubeId' WHERE movieId=$movieId;";
        $this->_dbConnection->query($sql);
    }
    
    /**
     * Gets statistics for the n most recently completed movies
     */
    public function getMovieStatistics($n=100)
    {
        $this->_dbConnect();
        
        $sql = "SELECT numFrames, width * height as numPixels, queueNum, " .
               "TIMESTAMPDIFF(SECOND, buildTimeStart, buildTimeEnd) as time " .
               "FROM movies " .
               "WHERE TIMESTAMPDIFF(SECOND, buildTimeStart, buildTimeEnd) > 0 " .
               "ORDER BY id DESC LIMIT $n;";

        $result = $this->_dbConnection->query($sql);

        // Fetch result and store as column arrays instead of rows 
        $stats = array(
            "numFrames" => array(),
            "numPixels" => array(),
            "queueNum"  => array(),
            "time"      => array()
        );
        while ($row = $result->fetch_array()) {
            array_push($stats['numFrames'], $row[0]);
            array_push($stats['numPixels'], $row[1]);
            array_push($stats['queueNum'], $row[2]);
            array_push($stats['time'], $row[3]);
        }
        
        return $stats;
    }
    
    /**
     * Gets a list of videos recently shared on YouTube
     */
    public function getSharedVideos($num, $since, $force=false)
    {
        include_once 'src/Helper/DateTimeConversions.php';
        
        $cached = false;
        
        $cachedir = HV_CACHE_DIR.'/api/MovieDatabse/getSharedvideos';

        $filename = urlencode($since.'_'.$num.'.json');
        $filepath = $cachedir.'/'.$filename;

        if ( $force===false && @file_exists($filepath) ) {

            $fh = @fopen($filepath,'r');

            $contents = '';
            while (!@feof($fh)) {
                $contents .= @fread($fh, 8192);
            }
            @fclose($fh);

            $videos = json_decode($contents, true);

            if ( $videos === null ) {
                $cached = false;
                break;
            }

            $cached = true;
            
            $filemtime = @filemtime($filepath);

            if ( $filemtime !== false && time()-$filemtime > 90 ) {
                @unlink($filepath);
            } 
        }

        if ( $cached===false || $force===true ) {
            $this->_dbConnect();

            $date = isoDateToMySQL($since);

            $sql = "SELECT movieId, youtubeId, timestamp FROM youtube WHERE " .
                   "shared=1 AND youtubeId IS NOT NULL AND timestamp > '$date' ORDER BY id DESC LIMIT $num;";

            $videos = array();

            $result = $this->_dbConnection->query($sql);

            while ($row = $result->fetch_array(MYSQLI_ASSOC)) {
                array_push($videos, $row);
            }
            
            $temppath = HV_CACHE_DIR.'/api/getSharedVideos_'.time().'.json';
            
            
            if ( !@file_exists($cachedir) ) {
                @mkdir($cachedir, 0777, true);
            }
            
            $fh = @fopen($filepath,'w');

            if ( $fh !== false ) {
                @fwrite($fh, json_encode($videos));

                @fclose($fh);

                clearstatcache();

                if ( @rename($temppath, $filepath) === false ) {

                    if ( @copy($temppath, $filepath) ) {
                        @unlink($temppath);
                    }
                }
            }
            else {
                //error_log(__FILE__.':'.__LINE__
                //    .' -- Failed to write JSON cache for getSharedVideos API: '
                //    .$filepath);
            }
        }
        
        return $videos;
    }
}
